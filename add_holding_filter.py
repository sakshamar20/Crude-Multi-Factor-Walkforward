"""
Script to add a minimum holding period filter to all strategies,
reducing excessive trading and transaction costs.
"""
import json

notebook_path = r"C:\Users\Acer\Downloads\cand_proj\Sample Strategy.ipynb"

with open(notebook_path, "r", encoding="utf-8") as f:
    nb = json.load(f)

# Find the strategy cell
for cell in nb["cells"]:
    if cell["cell_type"] == "code":
        source_text = "".join(cell["source"])
        if "lookback_days" in source_text and "Run Walkforward Backtest" in source_text:
            # Build the entirely new source for this cell
            new_source = [
                '"""\n',
                "NOTE:\n",
                "This is a very basic draft strategy for illustrative purposes. This Strategy goes long or short based on the current strat selection - momentum or \n",
                "mean reversion and last n days return. \n",
                "- The walkforward backtester evaluates multiple strategies over a rolling lookback period.\n",
                "- At each rebalance, the best performing strategy (based on Sharpe ratio by default) is applied forward.\n",
                "- The strategy here (simple momentum vs mean reversion with fixed lookbacks) performs poorly as can be seen in performance charts for walfforward\n",
                "- Goal: use this framework to design a more robust strategy with better walkforward performance.\n",
                '"""\n',
                "\n",
                "\n",
                "# -------------------------------\n",
                "# Example Usage: Brent Index\n",
                "# -------------------------------\n",
                'df = pd.read_excel(r"brent_index.xlsx", parse_dates=[\'date\'], index_col=\'date\')\n',
                "rets = df['CO1 Comdty'].pct_change()\n",
                "tcost = 0.00015  # Transaction cost per trade\n",
                "\n",
                "# -------------------------------\n",
                "# Helper: Minimum Holding Period Filter\n",
                "# -------------------------------\n",
                "def apply_holding_period(signal, min_hold=5):\n",
                '    """Enforce a minimum holding period to reduce excessive trading.\n',
                "    Once a position is taken, it must be held for at least `min_hold` days\n",
                '    before the signal can change."""\n',
                "    filtered = signal.copy()\n",
                "    last_trade_idx = -min_hold  # allow first trade immediately\n",
                "    current_pos = 0\n",
                "    for i in range(len(filtered)):\n",
                "        if pd.isna(filtered.iloc[i]):\n",
                "            filtered.iloc[i] = current_pos\n",
                "            continue\n",
                "        if filtered.iloc[i] != current_pos:\n",
                "            if (i - last_trade_idx) >= min_hold:\n",
                "                current_pos = filtered.iloc[i]\n",
                "                last_trade_idx = i\n",
                "            else:\n",
                "                filtered.iloc[i] = current_pos  # keep old position\n",
                "        else:\n",
                "            filtered.iloc[i] = current_pos\n",
                "    return filtered\n",
                "\n",
                "min_hold = 5  # Minimum 5-day holding period (tune this parameter)\n",
                "\n",
                "# ------------------------------- # Define multiple strategies # ----------\n",
                "lookback_days = [2, 4, 8, 16, 32, 64, 128, 256] \n",
                "pnl_strategies = pd.DataFrame(index=rets.index) \n",
                "for m in lookback_days: #rolling returns till yesterday, Shift(1) below to remove look ahead bias \n",
                "    rolling_ret = (1 + rets).rolling(window=m).apply(np.prod, raw=True).shift(1) - 1 \n",
                "    \n",
                "    # Momentum: go long if past return > 0, else short \n",
                "    momentum_signal = pd.Series(np.where(rolling_ret > 0, 1, -1), index=rets.index) \n",
                "    momentum_signal = apply_holding_period(momentum_signal, min_hold)\n",
                '    pnl_strategies[f"{m}D_momentum"] = momentum_signal * rets - tcost * abs(momentum_signal.diff()) \n',
                "    \n",
                "    # Mean Reversion: go short if past return > 0, else long \n",
                "    meanrev_signal = pd.Series(np.where(rolling_ret > 0, -1, 1), index=rets.index) \n",
                "    meanrev_signal = apply_holding_period(meanrev_signal, min_hold)\n",
                '    pnl_strategies[f"{m}D_meanrev"] = meanrev_signal * rets - tcost * abs(meanrev_signal.diff())\n',
                "    \n",
                "# -------------------------------\n",
                "# Moving Average Crossover Strategies\n",
                "# -------------------------------\n",
                "ma_pairs = [(2,10),(5, 20), (10, 50), (20, 100), (50, 200), (100,300)]  # (short_window, long_window)\n",
                "for short_w, long_w in ma_pairs:\n",
                "    short_ma = df['CO1 Comdty'].rolling(window=short_w).mean()\n",
                "    long_ma = df['CO1 Comdty'].rolling(window=long_w).mean()\n",
                "    # Go long when short MA > long MA, else short\n",
                "    ma_signal = pd.Series(np.where(short_ma.shift(1) > long_ma.shift(1), 1, -1), index=rets.index)\n",
                "    ma_signal = apply_holding_period(ma_signal, min_hold)\n",
                '    pnl_strategies[f"{short_w}_{long_w}_ma_crossover"] = ma_signal * rets - tcost * abs(ma_signal.diff())\n',
                "\n",
                "# -------------------------------\n",
                "# Bollinger Band Reversion Strategies\n",
                "# -------------------------------\n",
                "bb_windows = [20, 50]\n",
                "for w in bb_windows:\n",
                "    mid = df['CO1 Comdty'].rolling(window=w).mean()\n",
                "    std = df['CO1 Comdty'].rolling(window=w).std()\n",
                "    upper = mid + 2 * std\n",
                "    lower = mid - 2 * std\n",
                "    price = df['CO1 Comdty']\n",
                "    # Long when price below lower band, short when above upper, else flat->use previous\n",
                "    bb_signal = pd.Series(np.where(price.shift(1) < lower.shift(1), 1,\n",
                "                         np.where(price.shift(1) > upper.shift(1), -1, np.nan)), index=rets.index)\n",
                "    bb_signal = bb_signal.ffill().fillna(0)\n",
                "    bb_signal = apply_holding_period(bb_signal, min_hold)\n",
                "    pnl_strategies[f'{w}D_bollinger'] = bb_signal * rets - tcost * abs(bb_signal.diff())\n",
                "\n",
                "# -------------------------------\n",
                "# RSI Strategies\n",
                "# -------------------------------\n",
                "rsi_windows = [14, 28]\n",
                "for w in rsi_windows:\n",
                "    delta = df['CO1 Comdty'].diff()\n",
                "    gain = delta.where(delta > 0, 0).rolling(window=w).mean()\n",
                "    loss = (-delta.where(delta < 0, 0)).rolling(window=w).mean()\n",
                "    rs = gain / loss\n",
                "    rsi = 100 - (100 / (1 + rs))\n",
                "    # Long when RSI < 30 (oversold), short when RSI > 70 (overbought)\n",
                "    rsi_signal = pd.Series(np.where(rsi.shift(1) < 30, 1,\n",
                "                          np.where(rsi.shift(1) > 70, -1, np.nan)), index=rets.index)\n",
                "    rsi_signal = rsi_signal.ffill().fillna(0)\n",
                "    rsi_signal = apply_holding_period(rsi_signal, min_hold)\n",
                "    pnl_strategies[f'{w}D_rsi'] = rsi_signal * rets - tcost * abs(rsi_signal.diff())\n",
                "\n",
                "# -------------------------------\n",
                "# Donchian Breakout Strategies\n",
                "# -------------------------------\n",
                "breakout_windows = [20, 55]\n",
                "for w in breakout_windows:\n",
                "    high_w = df['CO1 Comdty'].rolling(window=w).max()\n",
                "    low_w = df['CO1 Comdty'].rolling(window=w).min()\n",
                "    price = df['CO1 Comdty']\n",
                "    # Long on new high, short on new low\n",
                "    brk_signal = pd.Series(np.where(price.shift(1) >= high_w.shift(2), 1,\n",
                "                          np.where(price.shift(1) <= low_w.shift(2), -1, np.nan)), index=rets.index)\n",
                "    brk_signal = brk_signal.ffill().fillna(0)\n",
                "    brk_signal = apply_holding_period(brk_signal, min_hold)\n",
                "    pnl_strategies[f'{w}D_breakout'] = brk_signal * rets - tcost * abs(brk_signal.diff())\n",
                "\n",
                "# -------------------------------\n",
                "# Run Walkforward Backtest\n",
                "# -------------------------------\n",
                "backtester = WalkforwardBacktester(\n",
                "    pnl_df=pnl_strategies,\n",
                "    lookback_period='24M',\n",
                "    rebalance_freq='3M'\n",
                ")\n",
                "\n",
                "portfolio_pnl = backtester.run_backtest()\n",
                "\n",
                "# -------------------------------\n",
                "# Inspect Rebalance Decisions\n",
                "# -------------------------------\n",
                "rebalance_details = backtester.get_rebalance_details()\n",
                "\n",
                "# -------------------------------\n",
                "# Portfolio Performance\n",
                "# -------------------------------\n",
                "portfolio_cum = (1 + portfolio_pnl).cumprod()\n",
                'portfolio_cum.plot(title="Walkforward Portfolio Cumulative Returns (Momentum vs Mean Reversion)")',
            ]

            cell["source"] = new_source
            print("Successfully replaced strategy cell with holding-period-filtered version!")
            break

with open(notebook_path, "w", encoding="utf-8") as f:
    json.dump(nb, f, indent=1)

print("Notebook saved.")
